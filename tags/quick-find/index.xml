<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Quick Find on Strata</title>
    <link>http://replace-this-with-your-hugo-site.com/tags/quick-find/</link>
    <description>Recent content in Quick Find on Strata</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 Sep 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://replace-this-with-your-hugo-site.com/tags/quick-find/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Dynamic Connectivity: Quick-Find</title>
      <link>http://replace-this-with-your-hugo-site.com/2013/09/21/dynamic-connectivity-quick-find/</link>
      <pubDate>Sat, 21 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2013/09/21/dynamic-connectivity-quick-find/</guid>
      <description>&lt;figure&gt;
  &lt;a href=&#34;http://replace-this-with-your-hugo-site.com/images/DynamicConnectivity.jpg&#34;&gt;&lt;img src=&#34;http://replace-this-with-your-hugo-site.com/images/DynamicConnectivity.jpg&#34;&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;Let&amp;#8217;s assume our object can be identified by an integer number, we can use an integer Array as data structure for our solution (&lt;em&gt;id[]&lt;/em&gt;) . In Quick-Find we consider two sites &lt;em&gt;p&lt;/em&gt; and &lt;em&gt;q&lt;/em&gt; are in the same component if &lt;em&gt;id[p]&lt;/em&gt; is equal do &lt;em&gt;id[q]&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;initQuickFindUF&lt;/em&gt; function allocates the zeroed array and assign the slice that refers to that array to &lt;em&gt;Elements&lt;/em&gt;; then go through it and set the value corresponding to each index ( *Elements[i] = i *).&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;connected&lt;/em&gt; function simply checks whether given two index &lt;em&gt;(p, q)&lt;/em&gt; their entries are equal and returns.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;union&lt;/em&gt; function is a little more complicated: given two index  *(p, q)* it retrieves their entries in the array, then loop through the whole array looking for entries equal to the &lt;em&gt;p&lt;/em&gt; entry and set those to q entry.&lt;/p&gt;

&lt;div class=&#34;divider&#34;&gt;
&lt;/div&gt;


package dyncon

type QuickFindUF struct {
   Elements []int
}

func initQuickFindUF(size int) *QuickFindUF {
   qfUF := QuickFindUF{Elements: make([]int, size)}
   for i := range qfUF.Elements {
      qfUF.Elements[i] = i
   }
   return &amp;qfUF
}

func (qfUF QuickFindUF) connected(p, q int) bool {
   return qfUF.Elements[p] == qfUF.Elements[q]
}

func (qfUF *QuickFindUF) union(p, q int) {
   pid := qfUF.Elements[p]
   qid := qfUF.Elements[q]
   for i := range qfUF.Elements {
      if qfUF.Elements[i] == pid {
         qfUF.Elements[i] = qid
      }
   }
}


&lt;p&gt;By evaluating this algorithm by the number of times it access the array we can assume the following measurements:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Algorithm&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;initQuickFindUF&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;connected&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;union&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Quick-Find&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;N&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;=====&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;em&gt;union&lt;/em&gt; function costs N accesses to the array; if we have N union operations this algorithm will take quadratic time complexity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So the Quick-find algorithm is too slow for big N.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>