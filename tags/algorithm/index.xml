<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Laquysoft</title>
    <link>/wwww.laquysoft.com/tags/algorithm/index.xml</link>
    <description>Recent content in Algorithm on Laquysoft</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/wwww.laquysoft.com/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Dynamic Connectivity: Quick-Union in Go</title>
      <link>/wwww.laquysoft.com/2013/09/dynamic-connectivity-quick-union-in-go/</link>
      <pubDate>Mon, 30 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>/wwww.laquysoft.com/2013/09/dynamic-connectivity-quick-union-in-go/</guid>
      <description>&lt;figure&gt;
  &lt;a href=&#34;wwww.laquysoft.com/images/gopher_tree.jpg&#34;&gt;&lt;img src=&#34;wwww.laquysoft.com/images/gopher_tree.jpg&#34;&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;Understood &lt;a href=&#34;http://www.laquysoft.com//2013/09/dynamic-connectivity-quick-find/&#34; title=&#34;Dynamic Connectivity: Quick-Find&#34; target=&#34;_blank&#34;&gt;Quick-Find&lt;/a&gt; algorithm is too slow if we have many union operations. We have to design a new algorithm to do better, let&amp;#8217;s use a &lt;em&gt;lazy approach&lt;/em&gt; where we try to avoid doing work until we have to:&lt;br /&gt;
we could think the array as a set of trees where each entry contains a reference to its parent in the tree. Each element of the array has associated with it a root and we can say that two elements are connected if they have the same root.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;connected&lt;/em&gt; function simply checks whether given two index (p, q) their root are equal and returns.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;union&lt;/em&gt; function here is simpler then &lt;a href=&#34;http://www.laquysoft.com/2013/09/dynamic-connectivity-quick-find/&#34; title=&#34;Dynamic Connectivity: Quick-Find&#34; target=&#34;_blank&#34;&gt;Quick-Find&lt;/a&gt; one, given two index &lt;em&gt;(p, q)&lt;/em&gt; it retrieves their roots &lt;em&gt;(i, j)&lt;/em&gt; and set &lt;em&gt;i&lt;/em&gt; to &lt;em&gt;j&lt;/em&gt; (the root of &lt;em&gt;q&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;root&lt;/em&gt; function given an element &lt;em&gt;i&lt;/em&gt; look for the its parent until &lt;em&gt;i&lt;/em&gt; is equal to &lt;em&gt;id[i]&lt;/em&gt;, when we reach the root element.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&#34;go&#34;&gt;
package dyncon

type QuickUnionUF struct {
   Elements []int
}

func initQuickUnionUF(size int) *QuickUnionUF {
   quUF := QuickUnionUF{Elements: make([]int, size)}
   for i := range quUF.Elements {
      quUF.Elements[i] = i
   }
   return &amp;quUF
}

func (quUF QuickUnionUF) root(i int) int {
   for i != quUF.Elements[i] {
       i = quUF.Elements[i]
   }
   return i
}

func (quUF QuickUnionUF) connected(p, q int) bool {
   return quUF.root(p) == quUF.root(q)
}

func (quUF *QuickUnionUF) union(p, q int) {
   i := quUF.root(p)
   j := quUF.root(q)
   quUF.Elements[i] = j

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;By evaluating this algorithm by the number of times it access the array we can assume the following measurements:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Algorithm&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;initQuickUnionUF&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;connected&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;union&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Quick-Union&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;N&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;tree-height&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;tree-height&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;Union algorithm some times could be faster than &lt;a href=&#34;wwww.laquysoft.com/2013/09/dynamic-connectivity-quick-find/&#34; title=&#34;Dynamic Connectivity: Quick-Find&#34; target=&#34;_blank&#34;&gt;Quick-Find&lt;/a&gt; but it&amp;#8217;s too slow with tall trees!&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Connectivity: Quick-Find</title>
      <link>/wwww.laquysoft.com/2013/09/dynamic-connectivity-quick-find/</link>
      <pubDate>Sat, 21 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>/wwww.laquysoft.com/2013/09/dynamic-connectivity-quick-find/</guid>
      <description>&lt;figure&gt;
  &lt;a href=&#34;wwww.laquysoft.com/images/DynamicConnectivity.jpg&#34;&gt;&lt;img src=&#34;wwww.laquysoft.com/images/DynamicConnectivity.jpg&#34;&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;Let&amp;#8217;s assume our object can be identified by an integer number, we can use an integer Array as data structure for our solution (&lt;em&gt;id[]&lt;/em&gt;) . In Quick-Find we consider two sites &lt;em&gt;p&lt;/em&gt; and &lt;em&gt;q&lt;/em&gt; are in the same component if &lt;em&gt;id[p]&lt;/em&gt; is equal do &lt;em&gt;id[q]&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;initQuickFindUF&lt;/em&gt; function allocates the zeroed array and assign the slice that refers to that array to &lt;em&gt;Elements&lt;/em&gt;; then go through it and set the value corresponding to each index ( *Elements[i] = i *).&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;connected&lt;/em&gt; function simply checks whether given two index &lt;em&gt;(p, q)&lt;/em&gt; their entries are equal and returns.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;union&lt;/em&gt; function is a little more complicated: given two index  *(p, q)* it retrieves their entries in the array, then loop through the whole array looking for entries equal to the &lt;em&gt;p&lt;/em&gt; entry and set those to q entry.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;divider&#34;&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;code class=&#34;go&#34;&gt;
package dyncon
type QuickFindUF struct {
   Elements []int
}
func initQuickFindUF(size int) *QuickFindUF {
   qfUF := QuickFindUF{Elements: make([]int, size)}
   for i := range qfUF.Elements {
      qfUF.Elements[i] = i
   }
   return &amp;amp;qfUF
}
func (qfUF QuickFindUF) connected(p, q int) bool {
   return qfUF.Elements[p] == qfUF.Elements[q]
}
func (qfUF *QuickFindUF) union(p, q int) {
   pid := qfUF.Elements[p]
   qid := qfUF.Elements[q]
   for i := range qfUF.Elements {
      if qfUF.Elements[i] == pid {
         qfUF.Elements[i] = qid
      }
   }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;By evaluating this algorithm by the number of times it access the array we can assume the following measurements:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Algorithm&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;initQuickFindUF&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;connected&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;union&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Quick-Find&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;N&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;em&gt;union&lt;/em&gt; function costs N accesses to the array; if we have N union operations this algorithm will take quadratic time complexity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So the Quick-find algorithm is too slow for big N.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s Start</title>
      <link>/wwww.laquysoft.com/2013/09/lets-start/</link>
      <pubDate>Sat, 21 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>/wwww.laquysoft.com/2013/09/lets-start/</guid>
      <description>&lt;p&gt;&lt;figure&gt;
  &lt;a href=&#34;wwww.laquysoft.com/images/frodo_sam.jpg&#34;&gt;&lt;img src=&#34;wwww.laquysoft.com/images/frodo_sam.jpg&#34;&gt;&lt;/a&gt;
&lt;/figure&gt;
Let’s start this new adventure in blogger-land with a series of post about &lt;a href=&#34;http://en.wikipedia.org/wiki/Algorithm&#34;&gt;Algorithms&lt;/a&gt; and Go.
I choose this two characters because of two targets, to learn a new language ( &lt;a href=&#34;http://golang.org/&#34;&gt;Go&lt;/a&gt; ) and renew my neurons about the classic algorithms studied in the past; I want to mix an old ingredient with a new one. I’m sure this road could take me to perceive new approaches to common problems, and i’m sure this trip is going to be funny.
So…Let’s start!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>